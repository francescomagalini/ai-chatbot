# Chat Tools SDK Integration

## Overview

This backlog item focuses on updating the AI chat tools to create and update artifacts through the Ameide Core SDK instead of local database operations. It includes modifying the data stream handler to support SDK-based artifacts and implementing polling for updates.

## Prerequisites

- SDK foundation completed (001-a-sdk-foundation.md)
- Basic SDK client and auth bridge functional
- Feature flags configured

## Objectives

1. Update create-document tool to use SDK commands
2. Update update-document tool to use SDK commands
3. Modify data stream handler for SDK artifact IDs
4. Implement artifact tracking and polling triggers
5. Maintain backward compatibility with existing artifacts

## Technical Implementation

### 1. Updated Create Document Tool (`lib/ai/tools/create-document.ts`)

Modify the tool to create artifacts via SDK:

```typescript
import { generateUUID } from '@/lib/utils';
import { tool, type UIMessageStreamWriter } from 'ai';
import { z } from 'zod';
import type { Session } from 'next-auth';
import {
  artifactKinds,
  documentHandlersByArtifactKind,
} from '@/lib/artifacts/server';
import type { ChatMessage } from '@/lib/types';
import { shouldUseSDK } from '@/lib/ameide/features';
import { createArtifact } from '@/lib/ameide/queries';
import { CommandBuilder } from '@ameide/sdk';

interface CreateDocumentProps {
  session: Session;
  dataStream: UIMessageStreamWriter<ChatMessage>;
}

export const createDocument = ({ session, dataStream }: CreateDocumentProps) =>
  tool({
    description:
      'Create a document for a writing or content creation activities. This tool will call other functions that will generate the contents of the document based on the title and kind.',
    inputSchema: z.object({
      title: z.string(),
      kind: z.enum(artifactKinds),
    }),
    execute: async ({ title, kind }) => {
      const id = generateUUID();
      const useSDK = shouldUseSDK(kind);

      // Stream initial metadata
      dataStream.write({
        type: 'data-kind',
        data: kind,
        transient: true,
      });

      dataStream.write({
        type: 'data-id',
        data: id,
        transient: true,
      });

      dataStream.write({
        type: 'data-title',
        data: title,
        transient: true,
      });

      dataStream.write({
        type: 'data-clear',
        data: null,
        transient: true,
      });

      // Create artifact via SDK if enabled
      if (useSDK) {
        try {
          // Create artifact in SDK
          const result = await createArtifact(kind, title, {
            createdBy: 'ai-chat',
            chatSessionId: session.id,
          });

          // Update ID to match SDK artifact
          dataStream.write({
            type: 'data-sdk-id',
            data: result.aggregateId,
            transient: true,
          });

          // Signal to start polling
          dataStream.write({
            type: 'data-poll-start',
            data: {
              artifactId: result.aggregateId,
              kind,
            },
            transient: true,
          });
        } catch (error) {
          console.error('Failed to create artifact in SDK:', error);
          // Fall back to local creation
          dataStream.write({
            type: 'data-sdk-error',
            data: 'Failed to create in SDK, using local storage',
            transient: true,
          });
        }
      }

      // Get document handler
      const documentHandler = documentHandlersByArtifactKind.find(
        (documentHandlerByArtifactKind) =>
          documentHandlerByArtifactKind.kind === kind,
      );

      if (!documentHandler) {
        throw new Error(`No document handler found for kind: ${kind}`);
      }

      // Generate initial content
      await documentHandler.onCreateDocument({
        id: useSDK ? result?.aggregateId || id : id,
        title,
        dataStream,
        session,
      });

      // If using SDK, save initial content
      if (useSDK && result) {
        const initialContent = await documentHandler.getInitialContent?.({
          title,
          session,
        });

        if (initialContent) {
          // Create save command for initial content
          const saveCommand = CommandBuilder.createSaveCommand(
            CommandBuilder.createCommand(
              result.aggregateId,
              session.user.id,
              {
                metadata: {
                  action: 'initial-content',
                  source: 'ai-generated',
                },
              }
            ),
            {
              type: SaveCommand_SaveType.UPDATE,
              content: initialContent,
              description: 'Initial content generated by AI',
            }
          );

          await client.executeCommand(saveCommand);
        }
      }

      dataStream.write({ type: 'data-finish', data: null, transient: true });

      return {
        id: useSDK ? result?.aggregateId || id : id,
        title,
        kind,
        content: 'A document was created and is now visible to the user.',
        isSDKArtifact: useSDK,
      };
    },
  });
```

### 2. Updated Update Document Tool (`lib/ai/tools/update-document.ts`)

Modify to update artifacts via SDK:

```typescript
import { tool, type UIMessageStreamWriter } from 'ai';
import type { Session } from 'next-auth';
import { z } from 'zod';
import { getDocumentById } from '@/lib/db/queries';
import { documentHandlersByArtifactKind } from '@/lib/artifacts/server';
import type { ChatMessage } from '@/lib/types';
import { shouldUseSDK } from '@/lib/ameide/features';
import { getArtifact, getArtifactSnapshot } from '@/lib/ameide/queries';
import { BPMNCommandBuilder, CommandBuilder } from '@ameide/sdk';
import { createAmeideClientWithSession } from '@/lib/ameide/client';

interface UpdateDocumentProps {
  session: Session;
  dataStream: UIMessageStreamWriter<ChatMessage>;
}

export const updateDocument = ({ session, dataStream }: UpdateDocumentProps) =>
  tool({
    description: 'Update a document with the given description.',
    inputSchema: z.object({
      id: z.string().describe('The ID of the document to update'),
      description: z
        .string()
        .describe('The description of changes that need to be made'),
    }),
    execute: async ({ id, description }) => {
      let document: any;
      let useSDK = false;
      let currentContent: string | null = null;

      // Try SDK first if feature is enabled
      if (shouldUseSDK()) {
        try {
          const artifact = await getArtifact(id);
          if (artifact) {
            useSDK = true;
            const snapshot = await getArtifactSnapshot(id);
            currentContent = snapshot?.content || null;
            
            document = {
              id: artifact.id,
              title: artifact.metadata?.title || 'Untitled',
              kind: artifact.type as any,
              content: currentContent,
              createdAt: artifact.createdAt,
              userId: artifact.createdBy,
            };
          }
        } catch (error) {
          console.warn('Failed to fetch from SDK, falling back to DB:', error);
        }
      }

      // Fall back to database if SDK didn't work
      if (!document) {
        document = await getDocumentById({ id });
      }

      if (!document) {
        return {
          error: 'Document not found',
        };
      }

      dataStream.write({
        type: 'data-clear',
        data: null,
        transient: true,
      });

      // Get document handler
      const documentHandler = documentHandlersByArtifactKind.find(
        (documentHandlerByArtifactKind) =>
          documentHandlerByArtifactKind.kind === document.kind,
      );

      if (!documentHandler) {
        throw new Error(`No document handler found for kind: ${document.kind}`);
      }

      // Handle BPMN updates specially when using SDK
      if (useSDK && document.kind === 'bpmn') {
        // Parse the description to understand what changes to make
        const changes = await parseBpmnChanges(description, currentContent);
        
        if (changes.commands.length > 0) {
          const client = createAmeideClientWithSession(session);
          
          // Execute all commands
          for (const command of changes.commands) {
            await client.executeCommand(command);
          }
          
          // Trigger polling update
          dataStream.write({
            type: 'data-poll-refresh',
            data: {
              artifactId: id,
              kind: 'bpmn',
            },
            transient: true,
          });
        }
      } else {
        // Use existing handler for non-SDK or non-BPMN updates
        await documentHandler.onUpdateDocument({
          document,
          description,
          dataStream,
          session,
        });

        // If using SDK, save the updated content
        if (useSDK) {
          const updatedContent = await documentHandler.getContent?.(document);
          
          if (updatedContent) {
            const saveCommand = CommandBuilder.createSaveCommand(
              CommandBuilder.createCommand(
                id,
                session.user.id,
                {
                  metadata: {
                    action: 'ai-update',
                    description,
                  },
                }
              ),
              {
                type: SaveCommand_SaveType.UPDATE,
                content: updatedContent,
                description: `AI update: ${description}`,
              }
            );

            const client = createAmeideClientWithSession(session);
            await client.executeCommand(saveCommand);
          }
        }
      }

      dataStream.write({ type: 'data-finish', data: null, transient: true });

      return {
        id,
        title: document.title,
        kind: document.kind,
        content: 'The document has been updated successfully.',
        isSDKArtifact: useSDK,
      };
    },
  });

// Helper function to parse BPMN changes into commands
async function parseBpmnChanges(
  description: string,
  currentXml: string | null
): Promise<{ commands: Command[] }> {
  // This would use an LLM to understand the description
  // and generate appropriate BPMN commands
  // For now, return empty array
  return { commands: [] };
}
```

### 3. Enhanced Data Stream Handler (`components/data-stream-handler.tsx`)

Add SDK artifact support:

```typescript
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { artifactDefinitions } from './artifact';
import { initialArtifactData, useArtifact } from '@/hooks/use-artifact';
import { useDataStream } from './data-stream-provider';
import { useArtifactPolling } from '@/hooks/use-artifact-polling';

export function DataStreamHandler() {
  const { dataStream } = useDataStream();
  const { artifact, setArtifact, setMetadata } = useArtifact();
  const lastProcessedIndex = useRef(-1);
  
  // SDK artifact polling
  const [pollingArtifactId, setPollingArtifactId] = useState<string | null>(null);
  const { data: sdkArtifact, refresh } = useArtifactPolling(pollingArtifactId, {
    enabled: !!pollingArtifactId,
    onUpdate: (data) => {
      // Update artifact content when SDK data changes
      if (data?.content) {
        setArtifact((draft) => ({
          ...draft,
          content: data.content,
          version: data.version,
          lastModified: data.lastModified,
        }));
      }
    },
  });

  useEffect(() => {
    if (!dataStream?.length) return;

    const newDeltas = dataStream.slice(lastProcessedIndex.current + 1);
    lastProcessedIndex.current = dataStream.length - 1;

    newDeltas.forEach((delta) => {
      const artifactDefinition = artifactDefinitions.find(
        (artifactDefinition) => artifactDefinition.kind === artifact.kind,
      );

      if (artifactDefinition?.onStreamPart) {
        artifactDefinition.onStreamPart({
          streamPart: delta,
          setArtifact,
          setMetadata,
        });
      }

      setArtifact((draftArtifact) => {
        if (!draftArtifact) {
          return { ...initialArtifactData, status: 'streaming' };
        }

        switch (delta.type) {
          case 'data-id':
            return {
              ...draftArtifact,
              documentId: delta.data,
              status: 'streaming',
            };

          case 'data-sdk-id':
            // Update to SDK artifact ID
            setPollingArtifactId(delta.data);
            return {
              ...draftArtifact,
              documentId: delta.data,
              isSDKArtifact: true,
              status: 'streaming',
            };

          case 'data-title':
            return {
              ...draftArtifact,
              title: delta.data,
              status: 'streaming',
            };

          case 'data-kind':
            return {
              ...draftArtifact,
              kind: delta.data,
              status: 'streaming',
            };

          case 'data-clear':
            return {
              ...draftArtifact,
              content: '',
              status: 'streaming',
            };

          case 'data-poll-start':
            // Start polling for SDK artifact
            setPollingArtifactId(delta.data.artifactId);
            return {
              ...draftArtifact,
              isSDKArtifact: true,
              status: 'streaming',
            };

          case 'data-poll-refresh':
            // Trigger immediate refresh
            refresh();
            return draftArtifact;

          case 'data-sdk-error':
            // Handle SDK errors
            console.error('SDK error:', delta.data);
            return {
              ...draftArtifact,
              sdkError: delta.data,
              isSDKArtifact: false,
            };

          case 'data-finish':
            return {
              ...draftArtifact,
              status: 'idle',
            };

          default:
            return draftArtifact;
        }
      });
    });
  }, [dataStream, setArtifact, setMetadata, artifact, refresh]);

  // Clean up polling when artifact changes
  useEffect(() => {
    return () => {
      setPollingArtifactId(null);
    };
  }, [artifact.documentId]);

  return null;
}
```

### 4. Artifact Metadata Extension

Extend artifact types to support SDK metadata:

```typescript
// lib/types.ts
export interface ArtifactData {
  documentId: string;
  title: string;
  kind: ArtifactKind;
  content: string;
  status: 'idle' | 'streaming';
  isSDKArtifact?: boolean;
  sdkError?: string;
  version?: bigint;
  lastModified?: Date;
  metadata?: Record<string, any>;
}
```

### 5. Backward Compatibility Layer

Ensure existing artifacts continue to work:

```typescript
// lib/ameide/compatibility.ts
export async function loadArtifact(
  id: string,
  kind?: string
): Promise<ArtifactData | null> {
  // Try SDK first if enabled
  if (shouldUseSDK(kind)) {
    try {
      const artifact = await getArtifact(id);
      if (artifact) {
        const snapshot = await getArtifactSnapshot(id);
        return {
          documentId: id,
          title: artifact.metadata?.title || 'Untitled',
          kind: artifact.type as ArtifactKind,
          content: snapshot?.content || '',
          status: 'idle',
          isSDKArtifact: true,
          version: snapshot?.version,
          lastModified: snapshot?.lastModified,
          metadata: artifact.metadata,
        };
      }
    } catch (error) {
      console.warn('SDK fetch failed, trying database:', error);
    }
  }

  // Fall back to database
  const document = await getDocumentById({ id });
  if (document) {
    return {
      documentId: id,
      title: document.title,
      kind: document.kind,
      content: document.content || '',
      status: 'idle',
      isSDKArtifact: false,
    };
  }

  return null;
}
```

## Testing Strategy

1. **Unit Tests**:
   - Test create document with SDK enabled/disabled
   - Test update document with various artifact types
   - Test data stream handler with SDK events

2. **Integration Tests**:
   - Test full flow: chat creates BPMN via SDK
   - Test polling updates when artifact changes
   - Test fallback when SDK is unavailable

3. **E2E Tests**:
   - Create artifact via chat
   - Verify artifact appears in UI
   - Update artifact and verify changes

## Migration Considerations

1. **Feature Flags**: Use per-artifact-type flags for gradual rollout
2. **Dual Support**: Support both SDK and DB artifacts simultaneously
3. **Error Handling**: Graceful fallback to DB when SDK fails
4. **Performance**: Monitor polling impact on performance
5. **User Experience**: No visible changes for end users

## Performance Optimizations

1. **Polling Optimization**:
   - Only poll when artifact is visible
   - Use exponential backoff for unchanged artifacts
   - Stop polling after inactivity timeout

2. **Caching**:
   - Cache artifact metadata
   - Cache recent snapshots
   - Use ETags for efficient polling

3. **Batch Operations**:
   - Batch multiple tool calls
   - Combine related commands

## Success Criteria

- [ ] Chat can create artifacts via SDK
- [ ] Chat can update artifacts via SDK
- [ ] Polling updates UI when artifacts change
- [ ] Existing DB artifacts continue to work
- [ ] Performance remains acceptable
- [ ] Error handling provides good UX
- [ ] Feature flags control rollout

## Dependencies

- SDK foundation (001-a) must be complete
- SDK client must be properly configured
- Feature flags must be set up

## Next Steps

After this integration:
1. Add WebSocket support for real-time updates
2. Implement collaborative editing features
3. Add version history UI
4. Optimize polling with smart diffing
5. Add support for remaining artifact types (code, text, etc.)